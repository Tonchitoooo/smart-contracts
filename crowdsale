
pragma solidity ^0.4.21;
 
/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
  uint256 public totalSupply;                                             /* Возвращает суммарное количество выпущенных монет. Эту функцию может вызвать любой.*/
  function balanceOf(address who) constant returns (uint256);             /*Возвращает количество монет принадлежащих _owner. Может вызвать любой. Кошельки для отображения вашей монеты вызывают именно эту функцию.*/
  function transfer(address to, uint256 value) returns (bool);            /*Передает _value монет на адрес _to. Когда пользователь будет перемещать свои монеты на другой адрес вызываться будет именно эта функция. Соответственно монеты должны браться с баланса пользователя, который вызвал эту функцию. Метод должен создавать событие Transfer (описан будет далее) в случае успешного перемещения монет.*/     
  event Transfer(address indexed from, address indexed to, uint256 value);/*Событие, которое должно возникать при любом перемещении монет. Т.е. его нужно создавать внутри функций transfer и  transferFrom в случае успешного перемещения монет*/ 
}
 
/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) constant returns (uint256); /*Возвращает сколько монет со своего счета разрешил снимать пользователь _owner пользователю _spender.*/ 
  function transferFrom(address from, address to, uint256 value) returns (bool); /*Передает _ value монет от _from к _to. Пользователь должен иметь разрешение на перемещение монеток между адресами, дабы любой желающий не смог управлять чужими кошельками. Фактически эта функция позволяет вашему доверенному лицу распоряжаться определенным объемом монеток на вашем счету. Дать разрешение на управление средствами можно следующей функцией. Метод должен создавать событие Transfer (описан будет далее) в случае успешного перемещения монет.*/
  function approve(address spender, uint256 value) returns (bool);               /*Разрешает пользователю _spender снимать с вашего счета (точнее со счета вызвавшего функцию пользователя) средства не более чем _value. На основе этого разрешения должна работать функция transferFrom. Метод должен создавать событие Approval (описан будет далее).*/
  event Approval(address indexed owner, address indexed spender, uint256 value); /*Событие должно возникать при получении разрешения на снятие монет. Фактически должно создаваться внутри функции  approve.*/
}
 
/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
    
  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
 
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return a / b;
  

  }
 
  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b <= a);
    return a - b;
  }
 
  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
  
}
 
/**
 * @title Basic token
 * @dev Basic version of StandardToken, with no allowances. 
 */
contract BasicToken is ERC20Basic {
    
  using SafeMath for uint256;
 
  mapping(address => uint256) balances;
 
  /**
  * @dev transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) returns (bool) {
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }
 
  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of. 
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }
 
}
 
/**
 * @title Standard ERC20 token
 *
 * @dev Implementation of the basic standard token.
 * @dev https://github.com/ethereum/EIPs/issues/20
 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 */
contract StandardToken is ERC20, BasicToken {
 
  mapping (address => mapping (address => uint256)) allowed;  /*Первый ключ — адрес на снятие с которого предоставляется разрешение. Второй ключ — пользователь, которому предоставляется разрешение.*/
 
  /**
   * @dev Transfer tokens from one address to another
   * @param _from address The address which you want to send tokens from
   * @param _to address The address which you want to transfer to
   * @param _value uint256 the amout of tokens to be transfered
   */
  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {
    var _allowance = allowed[_from][msg.sender];
 
    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // require (_value <= _allowance);
 
    balances[_to] = balances[_to].add(_value);
    balances[_from] = balances[_from].sub(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
 
  /**
   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) returns (bool) {
 
    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    require((_value == 0) || (allowed[msg.sender][_spender] == 0));
 
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
 
  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifing the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
 
}
 
/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of "user permissions".
 */
contract Ownable {
    
  address public owner;
 
  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() {
    owner = msg.sender;
  }
 
  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
 
  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) onlyOwner {
    require(newOwner != address(0));      
    owner = newOwner;
  }
 
}
 
/**
 * @title Mintable token
 * @dev Simple ERC20 Token example, with mintable token creation
 * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120
 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol
 */
 
contract MintableToken is StandardToken, Ownable {
    
  event Mint(address indexed to, uint256 amount);
  
  event MintFinished();
 
  bool public mintingFinished = false;
 
  modifier canMint() {
    require(!mintingFinished);
    _;
  }
 
  /**
   * @dev Function to mint tokens
   * @param _to The address that will recieve the minted tokens.
   * @param _amount The amount of tokens to mint.
   * @return A boolean that indicates if the operation was successful.
   */
  function mint(address _to, uint256 _amount) onlyOwner canMint returns (bool) {
    totalSupply = totalSupply.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    Mint(_to, _amount);
    return true;
  }
 
  /**
   * @dev Function to stop minting new tokens.
   * @return True if the operation was successful.
   */
  function finishMinting() onlyOwner returns (bool) {
    mintingFinished = true;
    MintFinished();
    return true;
  }
  
}
 
contract SimpleTokenCoin is MintableToken {
    
    string public constant name = "Simple Coint Token";
    
    string public constant symbol = "SCT";
    
    uint32 public constant decimals = 18;
    
}
 
 
contract Crowdsale is Ownable {
    
    using SafeMath for uint;
    
    address public multisig;  /*В контракте ICO  обычно полученный эфир не отсылают на адрес владельца контракта, а отсылают его на отдельный адрес. Это делается затем, что на отдельном адресе может быть как обычный аккаунт, так и контракт эскроу (специальный счет, управляемый доверенными лицами,  в целях повышения доверия инвесторов). В нашем случае мы будем задавать адрес простого аккаунта в конструкторе. Называться у нас он будет multisig.*/
 
    uint public restrictedPercent; /*процент токенов, который мы хотим получить */
 
    address public restricted;     /*счёт*/    
 
    SimpleTokenCoin public token = new SimpleTokenCoin();
 
    uint public start;
    
    uint public period;
 
    uint public hardcap;
 
    uint public rate; /*пересчет эфира в наши токены. Инициализировать его также будем в конструкторе.*/
    
    uint public softcap;
    
   
    

    mapping(address => uint) public balances;
 
    function Crowdsale() {
      multisig = 0xEA15Adb66DC92a4BbCcC8Bf32fd25E2e86a2A770;
      restricted = 0xb3eD172CC64839FB0C0Aa06aa129f402e994e7De;
      restrictedPercent = 40; /*процент токенов на собственные нужды*/
      rate = 500000000;
      start = 1500379200;
      period = 50;
      hardcap = 25000;
      softcap = 10000;
    }
 
    modifier saleIsOn() {
      require(now > start && now < start + period * 1 days);
      _;
    }
	
    modifier isUnderHardCap() {
      require(multisig.balance <= hardcap);
      _;
    }
 
    function refund() {
      require(this.balance < softcap && now > start + period * 1 days);
      uint value = balances[msg.sender];    
      balances[msg.sender] = 0; 
      msg.sender.transfer(value); 
    }
 
    function finishMinting() public onlyOwner {
      if(this.balance > softcap) {
        multisig.transfer(this.balance);
        uint issuedTokenSupply = token.totalSupply();
        uint restrictedTokens = issuedTokenSupply.mul(restrictedPercent).div(100 - restrictedPercent);
        token.mint(restricted, restrictedTokens);
        token.finishMinting();
      }
    }
 
   function createTokens() isUnderHardCap saleIsOn payable {
     
      uint tokens = rate.mul(msg.value).div(1 ether);
      uint bonusTokens = 0;
      if(now < start + (period * 3 days)) {
        bonusTokens = tokens.div(uint256 (100 / 40));
      } else if(now >= start + (period * 3 days).div(5) && now < start + (period * 7 days)) {
        bonusTokens = tokens.div(uint256 (100 / 30));
      } else if(now >= start + (period * 7 days) && now < start + (period * 30 days)) {
        bonusTokens = tokens.div(uint256 (100 / 20));
      } else if(now >= start + (period * 30 days) && now < start + (period * 120 days)) {
        bonusTokens = tokens.div(uint256 (100 / 10));
      }
      tokens += bonusTokens;
      token.mint(msg.sender, tokens);
      balances[msg.sender] = balances[msg.sender].add(msg.value);
    }
 
    function() external payable {
      createTokens();
    }
    
}
